<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
  <title>Signature</title>
  <style>
    /* IMPORTANT: no scrolling, app-like layout */
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      padding: 16px;
      box-sizing: border-box;
      -webkit-user-select: none;
      user-select: none;
      background: #fff;
    }

    header { flex: 0 0 auto; }
    .controls { flex: 0 0 auto; display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 10px 0; }

    /* signature area grows to fill remaining space */
    .sig-wrap {
      flex: 1 1 auto;
      min-height: 0;
      position: relative;
      border: 1px solid rgba(0,0,0,.15);
      border-radius: 16px;
      overflow: hidden;
      background: transparent;

      /* critical for iOS gesture suppression in this region */
      touch-action: none;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .sig-line {
      position: absolute;
      left: 24px; right: 24px;
      top: 72%;
      height: 1px;
      background: rgba(0,0,0,.45);
      pointer-events: none;
    }

    .seg {
      display:inline-flex;
      border:1px solid rgba(0,0,0,.2);
      border-radius:10px;
      overflow:hidden;
    }
    .seg button { border:0; padding:10px 14px; background:#fff; }
    .seg button.active { background: rgba(10,102,255,.12); }

    button {
      padding:10px 14px; border-radius:10px;
      border:1px solid rgba(0,0,0,.2); background:#fff;
    }
    button.primary { background:#0a66ff; border-color:#0a66ff; color:#fff; }

    #out { flex: 0 0 auto; }
  </style>
</head>

<body>
  <header>
    <h2 style="margin:0 0 6px 0;">Sign with Apple Pencil</h2>
  </header>

  <div class="controls">
    <div class="seg">
      <button id="inkBlack" class="active" type="button">Black</button>
      <button id="inkBlue" type="button">Blue</button>
    </div>
    <button id="clear" type="button">Clear</button>
    <button id="save" class="primary" type="button">Save PNG</button>
  </div>

  <div class="sig-wrap" id="pad">
    <canvas id="sig"></canvas>
    <div class="sig-line" id="line"></div>
  </div>

  <div id="out"></div>

  <script>
    const pad = document.getElementById('pad');
    const canvas = document.getElementById('sig');
    const ctx = canvas.getContext('2d', { willReadFrequently: false });
    const line = document.getElementById('line');
    const out = document.getElementById('out');

    // ---- Ink ----
    let inkColor = '#000';
    const inkBlackBtn = document.getElementById('inkBlack');
    const inkBlueBtn = document.getElementById('inkBlue');

    function setInk(c) {
      inkColor = c;
      inkBlackBtn.classList.toggle('active', c === '#000');
      inkBlueBtn.classList.toggle('active', c !== '#000');
    }
    inkBlackBtn.onclick = () => setInk('#000');
    inkBlueBtn.onclick  = () => setInk('#0a66ff');

    // ---- Hi-DPI sizing ----
    let dpr = 1;
    function resize() {
      const r = canvas.getBoundingClientRect();
      dpr = window.devicePixelRatio || 1;

      canvas.width = Math.round(r.width * dpr);
      canvas.height = Math.round(r.height * dpr);

      // draw in CSS px
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.miterLimit = 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // ---- KEY ROBUSTNESS FIX #1:
    // Prevent default for ANY pointer interaction inside the pad (including palms),
    // so Safari never starts a pan/scroll gesture.
    const blockAllPointerDefaults = (e) => {
      e.preventDefault();
    };
    pad.addEventListener('pointerdown', blockAllPointerDefaults, { passive: false });
    pad.addEventListener('pointermove', blockAllPointerDefaults, { passive: false });
    pad.addEventListener('pointerup', blockAllPointerDefaults, { passive: false });
    pad.addEventListener('pointercancel', blockAllPointerDefaults, { passive: false });

    // Optional: also block touchmove at document level to avoid rubber-banding
    document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    // ---- Drawing (pencil only) ----
    let drawing = false;
    let activePenId = null;
    let points = [];

    const BASE_WIDTH = 2.2;      // "sharper" feel
    const PRESSURE_BOOST = 1.2;  // set 0 for fixed width

    function widthFor(p) {
      const pr = Math.max(0, Math.min(1, p ?? 0.5));
      return BASE_WIDTH + PRESSURE_BOOST * pr;
    }
    function mid(a,b){ return {x:(a.x+b.x)/2, y:(a.y+b.y)/2}; }
    function ptFrom(e){
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top, p: e.pressure ?? 0.5 };
    }

    function onMove(e) {
      if (!drawing) return;
      if (e.pointerId !== activePenId) return;
      if (e.pointerType !== 'pen') return;

      const p = ptFrom(e);
      points.push(p);

      ctx.strokeStyle = inkColor;

      const n = points.length;
      if (n === 2) {
        ctx.lineWidth = widthFor(points[1].p);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.stroke();
      } else if (n >= 3) {
        const p0 = points[n-3], p1 = points[n-2], p2 = points[n-1];
        const m1 = mid(p0,p1), m2 = mid(p1,p2);
        ctx.lineWidth = widthFor(p1.p);
        ctx.beginPath();
        ctx.moveTo(m1.x, m1.y);
        ctx.quadraticCurveTo(p1.x, p1.y, m2.x, m2.y);
        ctx.stroke();
      }
    }

    function endStroke(e) {
      if (e.pointerId !== activePenId) return;
      drawing = false;
      activePenId = null;
      window.removeEventListener('pointermove', onMove, { passive: false });
      window.removeEventListener('pointerup', endStroke, { passive: false });
      window.removeEventListener('pointercancel', endStroke, { passive: false });
    }

    // Real draw handler (separate from the default-blocker)
    pad.addEventListener('pointerdown', (e) => {
      // pencil only
      if (e.pointerType !== 'pen') return;

      drawing = true;
      activePenId = e.pointerId;
      points = [];

      const p = ptFrom(e);
      points.push(p);

      // dot for taps
      ctx.fillStyle = inkColor;
      ctx.beginPath();
      ctx.arc(p.x, p.y, widthFor(p.p) / 2, 0, Math.PI * 2);
      ctx.fill();

      // IMPORTANT: listen on window so we donâ€™t lose the stream
      window.addEventListener('pointermove', onMove, { passive: false });
      window.addEventListener('pointerup', endStroke, { passive: false });
      window.addEventListener('pointercancel', endStroke, { passive: false });
    }, { passive: false });

    // ---- Clear ----
    document.getElementById('clear').onclick = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      out.innerHTML = '';
      line.style.display = ''; // show again
    };

    // ---- Save (simple version: export full canvas; plug your crop logic here) ----
    document.getElementById('save').onclick = async () => {
      // hide line only after save click
      line.style.display = 'none';

      const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
      const url = URL.createObjectURL(blob);

      out.innerHTML = `
        <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
          <a download="signature.png" href="${url}">
            <button class="primary" type="button">Download signature.png</button>
          </a>
        </div>
      `;
    };
  </script>
</body>
</html>
